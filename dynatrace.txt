#!/usr/bin/env bash
set -euo pipefail

# ======== CONFIG ========
: "${DT_URL:?Set your Dynatrace URL, e.g. https://abc12345.live.dynatrace.com}"
: "${DT_TOKEN:?Set your Dynatrace API token with entities.read scope}"
MZ_NAME="${MZ_NAME:-}"               # e.g. "Production"
TIME_FROM="${TIME_FROM:-now-7d}"
TIME_TO="${TIME_TO:-}"
PAGE_SIZE="${PAGE_SIZE:-500}"
OUTDIR="${OUTDIR:-dt_export}"
FIELDS="${FIELDS:-+properties,+tags,+managementZones,+fromRelationships,+toRelationships,+lastSeenTms}"

# Which entity types to fetch (add APPLICATION if you want UI/frontends)
ENTITY_TYPES="${ENTITY_TYPES:-HOST,PROCESS_GROUP,SERVICE}"

# Draw.io layout params
NODE_W="${NODE_W:-180}"
NODE_H="${NODE_H:-60}"
GUTTER_X="${GUTTER_X:-240}"
GUTTER_Y="${GUTTER_Y:-30}"
PAD_X="${PAD_X:-40}"
PAD_Y="${PAD_Y:-40}"

# Column order (left -> right). Must match entity "type" values.
COL_ORDER="${COL_ORDER:-HOST,PROCESS_GROUP,SERVICE}"

# ======== Helpers ========
have_jq(){ command -v jq >/dev/null 2>&1; }
err(){ printf "\033[31m[err] %s\033[0m\n" "$*" >&2; }
hdr(){ printf "\n\033[1;36m== %s ==\033[0m\n" "$*"; }

api(){
  curl -sfSL -H "Authorization: Api-Token ${DT_TOKEN}" "$@" "${DT_URL}$1"
}

fetch_entities() {
  local type="$1"
  local selector="type(\"$type\")"
  if [[ -n "$MZ_NAME" ]]; then
    selector="$selector,mzName(\"$MZ_NAME\")"
  fi

  local base="/api/v2/entities"
  local qp="entitySelector=$(printf '%s' "$selector" | jq -sRr @uri)&pageSize=$PAGE_SIZE&fields=$(printf '%s' "$FIELDS" | jq -sRr @uri)"
  [[ -n "$TIME_FROM" ]] && qp="$qp&from=$(printf '%s' "$TIME_FROM" | jq -sRr @uri)"
  [[ -n "$TIME_TO" ]] && qp="$qp&to=$(printf '%s' "$TIME_TO" | jq -sRr @uri)"

  local out="$OUTDIR/raw/${type}.jsonl"
  : > "$out"

  hdr "Fetching $type"
  local resp
  resp="$(api "$base?$qp")" || { err "Initial fetch failed for $type"; return 1; }
  printf '%s\n' "$resp" | jq -c '.entities[]?' >> "$out" || true

  local next
  next="$(printf '%s' "$resp" | jq -r '.nextPageKey // empty' || true)"
  while [[ -n "$next" && "$next" != "null" ]]; do
    resp="$(api "$base?nextPageKey=$(printf '%s' "$next" | jq -sRr @uri)")" || { err "Pagination failed for $type"; break; }
    printf '%s\n' "$resp" | jq -c '.entities[]?' >> "$out" || true
    next="$(printf '%s' "$resp" | jq -r '.nextPageKey // empty' || true)"
  done
  printf "[ok] Saved %s entities → %s\n" "$type" "$out"
}

build_nodes_edges_csv() {
  hdr "Building nodes.csv / edges.csv"
  printf 'id,type,name,zone,tags\n' > "$OUTDIR/nodes.csv"
  printf 'srcId,rel,dstId\n' > "$OUTDIR/edges.csv"

  cat "$OUTDIR"/raw/*.jsonl 2>/dev/null | jq -r '
    . as $e |
    [
      $e.entityId,
      $e.type,
      ($e.displayName // $e.entityId),
      (([$e.managementZones[]?.name] | join("|")) // ""),
      (([$e.tags[]?.stringRepresentation] | join("|")) // "")
    ] | @csv
  ' >> "$OUTDIR/nodes.csv"

  # toRelationships (e -> target)
  cat "$OUTDIR"/raw/*.jsonl 2>/dev/null | jq -r '
    . as $e |
    ($e.toRelationships // {}) | to_entries[]? as $t |
    $t.value[]? | [$e.entityId, $t.key, .id] | @csv
  ' >> "$OUTDIR/edges.csv"

  # fromRelationships (origin -> e)  (normalize to origin -> target)
  cat "$OUTDIR"/raw/*.jsonl 2>/dev/null | jq -r '
    . as $e |
    ($e.fromRelationships // {}) | to_entries[]? as $t |
    $t.value[]? | [.id, $t.key, $e.entityId] | @csv
  ' >> "$OUTDIR/edges.csv"

  printf "[ok] nodes.csv and edges.csv created in %s\n" "$OUTDIR"
}

build_drawio() {
  hdr "Building topology.drawio (native XML)"
  local xml="$OUTDIR/topology.drawio"
  local tmp_nodes="$OUTDIR/.nodes.enriched.jsonl"
  : > "$tmp_nodes"

  # Build a map of type -> column index
  IFS=',' read -r -a cols <<< "$COL_ORDER"
  declare -A COL_INDEX=()
  for i in "${!cols[@]}"; do COL_INDEX["${cols[$i]}"]="$i"; done

  # Enrich nodes with col/row & coordinates
  # We’ll place nodes by their type column; rows increment as we go.
  # To get stable rows, sort nodes by name within each column.
  # Produce json lines: {"id":..,"name":..,"type":..,"x":..,"y":..}
  if ! have_jq; then
    err "jq is required for draw.io generation."
    return 1
  fi

  # Split nodes by column, sort by name
  for t in "${cols[@]}"; do
    grep -F ",$t," "$OUTDIR/nodes.csv" || true
  done >/dev/null 2>&1

  # Create per-column node lists
  for t in "${cols[@]}"; do
    awk -F, -v want="$t" 'NR==1{next} $2==want{print}' "$OUTDIR/nodes.csv" | sort -t, -k3,3 > "$OUTDIR/.col_${t}.csv" || true
  done

  # Assign coordinates
  for t in "${cols[@]}"; do
    row=0
    while IFS=, read -r id type name zone tags; do
      # strip surrounding quotes from CSV fields
      id="${id%\"}"; id="${id#\"}"
      type="${type%\"}"; type="${type#\"}"
      name="${name%\"}"; name="${name#\"}"
      col_idx="${COL_INDEX[$type]:-0}"
      x=$(( PAD_X + col_idx * GUTTER_X ))
      y=$(( PAD_Y + row * (GUTTER_Y + NODE_H) ))
      printf '{"id":"%s","name":"%s","type":"%s","x":%d,"y":%d}\n' \
        "$id" "$(printf '%s' "$name" | sed 's/"/\\"/g')" "$type" "$x" "$y" >> "$tmp_nodes"
      row=$((row+1))
    done < "$OUTDIR/.col_${t}.csv"
  done

  # Start XML
  {
    echo '<mxfile host="DynatraceExporter" modified="'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'" agent="bash" version="22.0.0">'
    echo '  <diagram name="Dynatrace Topology">'
    echo '    <mxGraphModel>'
    echo '      <root>'
    echo '        <mxCell id="0"/><mxCell id="1" parent="0"/>'
  } > "$xml"

  # Write node cells
  nid=100
  while read -r line; do
    id=$(jq -r '.id' <<<"$line")
    name=$(jq -r '.name' <<<"$line")
    type=$(jq -r '.type' <<<"$line")
    x=$(jq -r '.x' <<<"$line")
    y=$(jq -r '.y' <<<"$line")
    label="${name//&/&amp;}"
    label="${label//</&lt;}"
    label="${label//>/&gt;}"
    label="${label//\"/&quot;}"
    echo "        <mxCell id=\"$id\" value=\"$label&#10;($type)\" style=\"rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;\" vertex=\"1\" parent=\"1\">" >> "$xml"
    echo "          <mxGeometry x=\"$x\" y=\"$y\" width=\"$NODE_W\" height=\"$NODE_H\" as=\"geometry\"/>" >> "$xml"
    echo "        </mxCell>" >> "$xml"
    nid=$((nid+1))
  done < "$tmp_nodes"

  # Build a set of valid node IDs for edge validation
  mapfile -t NODE_IDS < <(jq -r '.id' "$tmp_nodes")

  # Edges (filter to only connect nodes that exist in our layout)
  while IFS=, read -r src rel dst; do
    [[ "$src" == "srcId" ]] && continue
    src="${src%\"}"; src="${src#\"}"
    dst="${dst%\"}"; dst="${dst#\"}"
    # only if both ends exist
    if printf '%s\n' "${NODE_IDS[@]}" | grep -qx "$src" && printf '%s\n' "${NODE_IDS[@]}" | grep -qx "$dst"; then
      elabel="${rel//&/&amp;}"; elabel="${elabel//</&lt;}"; elabel="${elabel//>/&gt;}"; elabel="${elabel//\"/&quot;}"
      echo "        <mxCell id=\"e-${src}-${dst}\" value=\"$elabel\" edge=\"1\" parent=\"1\" source=\"$src\" target=\"$dst\">" >> "$xml"
      echo "          <mxGeometry relative=\"1\" as=\"geometry\"/>" >> "$xml"
      echo "        </mxCell>" >> "$xml"
    fi
  done < "$OUTDIR/edges.csv"

  # Close XML
  {
    echo '      </root>'
    echo '    </mxGraphModel>'
    echo '  </diagram>'
    echo '</mxfile>'
  } >> "$xml"

  printf "[ok] %s\n" "$xml"
  printf "Open in draw.io and use Arrange → Layout to auto-tidy if needed.\n"
}

main() {
  have_jq || { err "jq is required (brew install jq / apt-get install jq)"; exit 1; }
  mkdir -p "$OUTDIR/raw"

  IFS=',' read -r -a TYPES <<< "$ENTITY_TYPES"
  for t in "${TYPES[@]}"; do fetch_entities "$t"; done

  build_nodes_edges_csv
  build_drawio

  # Cleanup temp files
  rm -f "$OUTDIR"/.col_*.csv "$OUTDIR/.nodes.enriched.jsonl" || true

  hdr "Done. Open: $OUTDIR/topology.drawio"
}

main "$@"
------//////-------
chmod +x dynatrace-to-drawio.sh

# Basic (last 7 days)
DT_URL="https://<your-env-id>.live.dynatrace.com" \
DT_TOKEN="dt0c01.xxxxxx" \
./dynatrace-to-drawio.sh

# Narrow to your Production management zone & include Applications too
DT_URL="https://<your-env-id>.live.dynatrace.com" \
DT_TOKEN="dt0c01.xxxxxx" \
MZ_NAME="Production" \
ENTITY_TYPES="HOST,PROCESS_GROUP,SERVICE,APPLICATION" \
COL_ORDER="HOST,PROCESS_GROUP,SERVICE,APPLICATION" \
./dynatrace-to-drawio.sh


-------
#!/usr/bin/env bash
set -euo pipefail

# ====== USER CONFIG ======
# Provide ONE of the following:
#   1) DT_URL     -> full base, e.g. https://abc12345.live.dynatrace.com
#   2) DT_ENV_ID  -> env id like abc12345 (SaaS). We will try live/apps bases.
#   3) DT_GATEWAY -> Managed ActiveGate base like https://ag.myco:9999 and DT_ENV_ID for /e/<env>
: "${DT_TOKEN:?Set DT_TOKEN=dt0c01.xxxxx with entities.read}"
DT_URL="${DT_URL:-}"
DT_ENV_ID="${DT_ENV_ID:-}"
DT_GATEWAY="${DT_GATEWAY:-}"

# Scope/time (optional)
ENTITY_TYPES="${ENTITY_TYPES:-HOST,PROCESS_GROUP,SERVICE}"
ENTITY_SELECTOR_OVERRIDE="${ENTITY_SELECTOR_OVERRIDE:-}"   # e.g. type("SERVICE"),tag("owner:team-x")
TIME_FROM="${TIME_FROM:-now-7d}"
TIME_TO="${TIME_TO:-}"
PAGE_SIZE="${PAGE_SIZE:-500}"

# Draw.io layout
NODE_W="${NODE_W:-180}"; NODE_H="${NODE_H:-60}"
GUTTER_X="${GUTTER_X:-240}"; GUTTER_Y="${GUTTER_Y:-30}"
PAD_X="${PAD_X:-40}"; PAD_Y="${PAD_Y:-40}"
COL_ORDER="${COL_ORDER:-HOST,PROCESS_GROUP,SERVICE}"

OUTDIR="${OUTDIR:-dt_export}"
FIELDS="${FIELDS:-+properties,+tags,+managementZones,+fromRelationships,+toRelationships,+lastSeenTms}"

# ====== UTIL ======
die(){ echo -e "\033[31m[err]\033[0m $*" >&2; exit 1; }
note(){ echo -e "\033[36m[info]\033[0m $*"; }
have(){ command -v "$1" >/dev/null 2>&1; }

api() {
  local url="$1"; shift || true
  local body_file code
  body_file="$(mktemp)"
  code="$(curl -sS -o "$body_file" -w '%{http_code}' -H "Authorization: Api-Token ${DT_TOKEN}" "$url" "$@" || true)"
  if [[ -z "${code:-}" ]]; then
    echo "[err] No HTTP code from $url" >&2; head -c 400 "$body_file" >&2 || true; rm -f "$body_file"; return 1
  fi
  if (( code >= 400 )); then
    echo "[err] HTTP $code for $url" >&2; head -c 800 "$body_file" >&2 || true; echo >&2; rm -f "$body_file"; return 1
  fi
  cat "$body_file"; rm -f "$body_file"
}

# ====== PREFLIGHT: determine a working Environment API base ======
pick_base() {
  # If DT_URL provided, try it as-is.
  if [[ -n "$DT_URL" ]]; then
    note "Trying DT_URL=$DT_URL"
    api "${DT_URL%/}/api/v2/entityTypes" >/dev/null && { echo "${DT_URL%/}"; return; }
    die "DT_URL ($DT_URL) didn’t work for /api/v2/entityTypes (404/401/… see error above)."
  fi

  # If Managed via ActiveGate base is provided, require DT_ENV_ID and build /e/<env-id>
  if [[ -n "$DT_GATEWAY" && -n "$DT_ENV_ID" ]]; then
    local base="${DT_GATEWAY%/}/e/${DT_ENV_ID}"
    note "Trying Managed ActiveGate base: $base"
    api "$base/api/v2/entityTypes" >/dev/null && { echo "$base"; return; }
    die "ActiveGate base ($base) didn’t work."
  fi

  # If only env id is given, try SaaS candidates.
  if [[ -n "$DT_ENV_ID" ]]; then
    local candidates=(
      "https://${DT_ENV_ID}.live.dynatrace.com"
      # Some orgs look at apps.* in the browser, but Environment API v2 is still on live.*
      # We try apps.* just in case the tenant proxies it:
      "https://${DT_ENV_ID}.apps.dynatrace.com"
    )
    for c in "${candidates[@]}"; do
      note "Trying $c"
      if api "$c/api/v2/entityTypes" >/dev/null; then echo "$c"; return; fi
    done
    die "Couldn’t reach a working Environment API for env id ($DT_ENV_ID). Supply DT_URL instead."
  fi

  die "Please set DT_URL (preferred), or DT_ENV_ID, or DT_GATEWAY+DT_ENV_ID."
}

# ====== FETCH ======
fetch_entities() {
  local base="$1" type="$2"
  local selector
  if [[ -n "$ENTITY_SELECTOR_OVERRIDE" ]]; then
    selector="$ENTITY_SELECTOR_OVERRIDE"
  else
    selector="type(\"$type\")"
  fi

  local url="$base/api/v2/entities"
  local qs="entitySelector=$(printf '%s' "$selector" | jq -sRr @uri)&pageSize=$PAGE_SIZE&fields=$(printf '%s' "$FIELDS" | jq -sRr @uri)"
  [[ -n "$TIME_FROM" ]] && qs="$qs&from=$(printf '%s' "$TIME_FROM" | jq -sRr @uri)"
  [[ -n "$TIME_TO" ]]   && qs="$qs&to=$(printf '%s' "$TIME_TO"   | jq -sRr @uri)"

  local out="$OUTDIR/raw/${type}.jsonl"; : > "$out"
  note "Fetching $type (selector: $selector)"
  local resp next
  resp="$(api "$url?$qs")" || die "Initial fetch failed for $type"
  printf '%s\n' "$resp" | jq -c '.entities[]?' >> "$out" || true
  next="$(printf '%s' "$resp" | jq -r '.nextPageKey // empty' || true)"
  while [[ -n "$next" && "$next" != "null" ]]; do
    resp="$(api "$url?nextPageKey=$(printf '%s' "$next" | jq -sRr @uri)")" || break
    printf '%s\n' "$resp" | jq -c '.entities[]?' >> "$out" || true
    next="$(printf '%s' "$resp" | jq -r '.nextPageKey // empty' || true)"
  done
  note "Saved $(wc -l < "$out" | tr -d ' ') $type entities → $out"
}

build_nodes_edges_csv() {
  note "Building nodes.csv / edges.csv"
  printf 'id,type,name,zone,tags\n' > "$OUTDIR/nodes.csv"
  printf 'srcId,rel,dstId\n' > "$OUTDIR/edges.csv"

  cat "$OUTDIR"/raw/*.jsonl 2>/dev/null | jq -r '
    . as $e |
    [
      $e.entityId,
      $e.type,
      ($e.displayName // $e.entityId),
      (([$e.managementZones[]?.name] | join("|")) // ""),
      (([$e.tags[]?.stringRepresentation] | join("|")) // "")
    ] | @csv
  ' >> "$OUTDIR/nodes.csv"

  # toRelationships: e -> target
  cat "$OUTDIR"/raw/*.jsonl 2>/dev/null | jq -r '
    . as $e | ($e.toRelationships // {}) | to_entries[]? as $t
    | $t.value[]? | [$e.entityId, $t.key, .id] | @csv
  ' >> "$OUTDIR/edges.csv"

  # fromRelationships: origin -> e (normalize to origin -> target)
  cat "$OUTDIR"/raw/*.jsonl 2>/dev/null | jq -r '
    . as $e | ($e.fromRelationships // {}) | to_entries[]? as $t
    | $t.value[]? | [.id, $t.key, $e.entityId] | @csv
  ' >> "$OUTDIR/edges.csv"
}

build_drawio() {
  note "Building topology.drawio"
  local xml="$OUTDIR/topology.drawio"
  local tmp_nodes="$OUTDIR/.nodes.enriched.jsonl"; : > "$tmp_nodes"

  IFS=',' read -r -a cols <<< "$COL_ORDER"
  declare -A COL_INDEX=()
  for i in "${!cols[@]}"; do COL_INDEX["${cols[$i]}"]="$i"; done

  # Per-column sorted node lists
  for t in "${cols[@]}"; do
    awk -F, -v want="$t" 'NR==1{next} $2==want{print}' "$OUTDIR/nodes.csv" | sort -t, -k3,3 > "$OUTDIR/.col_${t}.csv" || true
  done

  # Assign coordinates and emit enriched JSON
  for t in "${cols[@]}"; do
    row=0
    while IFS=, read -r id type name zone tags; do
      [[ -z "${id:-}" ]] && continue
      id="${id%\"}"; id="${id#\"}"; type="${type%\"}"; type="${type#\"}"
      name="${name%\"}"; name="${name#\"}"
      col_idx="${COL_INDEX[$type]:-0}"
      x=$(( PAD_X + col_idx * GUTTER_X ))
      y=$(( PAD_Y + row * (GUTTER_Y + NODE_H) ))
      printf '{"id":"%s","name":"%s","type":"%s","x":%d,"y":%d}\n' \
        "$id" "$(printf '%s' "$name" | sed 's/"/\\"/g')" "$type" "$x" "$y" >> "$tmp_nodes"
      row=$((row+1))
    done < "$OUTDIR/.col_${t}.csv"
  done

  {
    echo '<mxfile host="DynatraceExporter" modified="'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'" agent="bash" version="22.0.0">'
    echo '  <diagram name="Dynatrace Topology">'
    echo '    <mxGraphModel><root><mxCell id="0"/><mxCell id="1" parent="0"/>'
  } > "$xml"

  # Nodes
  while read -r line; do
    id=$(jq -r '.id' <<<"$line"); name=$(jq -r '.name' <<<"$line")
    type=$(jq -r '.type' <<<"$line"); x=$(jq -r '.x' <<<"$line"); y=$(jq -r '.y' <<<"$line")
    label="${name//&/&amp;}"; label="${label//</&lt;}"; label="${label//>/&gt;}"; label="${label//\"/&quot;}"
    echo "      <mxCell id=\"$id\" value=\"$label&#10;($type)\" style=\"rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;\" vertex=\"1\" parent=\"1\"><mxGeometry x=\"$x\" y=\"$y\" width=\"$NODE_W\" height=\"$NODE_H\" as=\"geometry\"/></mxCell>" >> "$xml"
  done < "$tmp_nodes"

  # Edge filter: only connect nodes we placed
  mapfile -t NODE_IDS < <(jq -r '.id' "$tmp_nodes")
  while IFS=, read -r src rel dst; do
    [[ "$src" == "srcId" ]] && continue
    src="${src%\"}"; src="${src#\"}"; dst="${dst%\"}"; dst="${dst#\"}"
    if printf '%s\n' "${NODE_IDS[@]}" | grep -qx "$src" && printf '%s\n' "${NODE_IDS[@]}" | grep -qx "$dst"; then
      elabel="${rel//&/&amp;}"; elabel="${elabel//</&lt;}"; elabel="${elabel//>/&gt;}"; elabel="${elabel//\"/&quot;}"
      echo "      <mxCell id=\"e-${src}-${dst}\" value=\"$elabel\" edge=\"1\" parent=\"1\" source=\"$src\" target=\"$dst\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell>" >> "$xml"
    fi
  done < "$OUTDIR/edges.csv"

  echo '    </root></mxGraphModel></diagram></mxfile>' >> "$xml"
  note "Wrote $xml  (Open in draw.io → Arrange → Layout to tidy)"
}

main() {
  have jq || die "Please install jq"
  mkdir -p "$OUTDIR/raw"

  local BASE; BASE="$(pick_base)"
  note "Using Environment API base: $BASE"

  IFS=',' read -r -a TYPES <<< "$ENTITY_TYPES"
  for t in "${TYPES[@]}"; do fetch_entities "$BASE" "$t"; done

  build_nodes_edges_csv
  build_drawio

  rm -f "$OUTDIR"/.col_*.csv "$OUTDIR/.nodes.enriched.jsonl" || true
  note "Done. Outputs in $OUTDIR/"
}

main "$@"
https://dynatrace.godigit.com/e/7bc76e8d-f3c2-4c06-ba65-02b4e2449fb8/#smartscape;id=MOBILE_APPLICATION-5AD84A50E1B5405F;gtf=-2h;gf=all
